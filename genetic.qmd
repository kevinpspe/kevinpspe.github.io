# Genetic Matching {.unnumbered}

<br />

Like [distance matching](distance.qmd), genetic matching matches an individual that is treated (like Mia) with one that is not treated based on how **close** their confounding values are.

However, instead of using a standard mahalanobis distance, genetic matching uses a mahalanobis distance that puts different weights/emphasis on different confounders:

$$
\delta_{i, j}(\b W) = \sqrt{(\b x_i - \b x_j)^\top (\b\Sigma_x^{-1/2})^\top \b W \b\Sigma_x^{-1/2}  (\b x_i - \b x_j)}
$$

::: aside
Where $i$ and $j$ are two units we want to measure the distance between, $\b x$ are their confounder values, and $\b\Sigma_x$ is the covariance matrix of confounders. $\b W$ is a weights matrix.
:::

It is basically a way to measure distance across multiple dimensions, adjusting for the scale at which confounders are measured, and weighting some confounders more.

The weights $\b W$ are estimated to make the treated and untreated groups as similar as possible. Then, matching is done with the units that have the smallest distance.

::: {.callout-note appearance="minimal"}
<div>

**Kevin's Estimator Score**: <i class="fas fa-star"></i><i class="fas fa-star"></i><i class="fas fa-star"></i><i class="fas fa-star"></i><i class="far fa-star"></i> (4/5)

-   Genetic matching has been shown by studies to be the best performing matching estimator.
-   However, genetic matching is also more computationally intensive, so for large data sets, propensity score matching might be quicker.

</div>
:::

<br />

To implement propensity score matching, we will need the **Matching** and **MatchIt** package.

```{r, eval = FALSE}
library(Matching)
```

First, we need to estimate the propensity scores with a logistic regression. It is recommended to use the propensity score as one of the controls on which to genetic match on.

```{r, eval = FALSE}
propensity <- glm(D ~ X1 + X2,
                  data = my_data,
                  family = "binomial")
my_data$pscore <- predict(propensity,
                          type = "response")
```

Then, we use the **GenMatch()** function to estimate a weights matrix $\b W$:

```{r, eval = FALSE}
set.seed(333) #any number works
gen <- GenMatch(Tr = my_data$D,
                    X = my_data[,c("X1","X2","pscore")],
                    BalanceMatrix = my_data[,c("X1","X2")],   
                    estimand = "ATT",
                    M = 2,
                    replace = TRUE,
                    ties = FALSE,
                    distance.tolerance = 0,
                    print.level = 0,
                    pop.size = 200)
```

::: aside
You can increase pop.size to increase the accuracy - but it will increase the time and computational power needed.
:::

Now, let us conduct estimation with genetic matching:

```{r, eval = FALSE}
att <- Match(Y = my_data$Y,
             Tr = my_data$D,
             X = my_data[,c("X1","X2","pscore")],
             estimand = "ATT",
             M = 2,
             replace = TRUE,
             ties = FALSE,
             distance.tolerance = 0,
             Weight.matrix = gen$Weight.matrix,
             Weight = 3)
```

Our output will be the ATT.
