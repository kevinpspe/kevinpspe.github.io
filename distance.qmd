# Distance Matching {.unnumbered}

Mia is in our study and receives the treatment. Mia's causal effect is:

$$
\tau_{\text{Mia}} = \textcolor{purple}{Y^{(1)}_\text{Mia}} - \textcolor{red}{Y^{(0)}_\text{Mia}}
$$

::: small
The counterfactual outcome (not observed) is in red.
:::

We cannot observe Mia's counterfactual. However, what we can do is to find an untreated individual similar to Mia to approximate Mia's counterfactual:

$$
\tau_{\text{Mia}} \approx \textcolor{purple}{Y^{(1)}_\text{Mia}} - \textcolor{purple}{Y^{(0)}_\text{Matched individual}} 
$$

Distance matching matches an individual that is treated (like Mia) with one that is not treated based on how **close** their confounding values are. We define closeness by Mahalanobis distance:

$$
\delta_{i, j} = \sqrt{(\b x_i - \b x_j)^\top \b\Sigma_x^{-1} (\b x_i - \b x_j)}
$$

::: small
Where $i$ and $j$ are two units we want to measure the distance between, $\b x$ is a vector of confounder values, and $\b\Sigma_x$ is the covariance matrix of confounders.
:::

::: {.callout-note appearance="minimal"}
<div>

**Kevin's Estimator Score**: <i class="fas fa-star"></i><i class="fas fa-star"></i><i class="far fa-star"></i><i class="far fa-star"></i><i class="far fa-star"></i> (2/5)

-   Distance matching performs worse than [genetic matching](genetic.qmd). However it is much quicker to estimate, so in larger datasets, you might consider to use distance matching.
-   **You should not use distance matching on any dataset with more than 4 confounders**, as it is badly biased by the [curse of dimensionality](https://en.wikipedia.org/wiki/Curse_of_dimensionality).
-   All matching methods are data inefficient - they will throw out unmatched data, and this can greatly reduce our sample sizes.
-   Matching is non-parametric, so it does not assume a linear relationship like regression.

</div>
:::

Before you implement distance matching, make sure you have reasons to believe you meet the neccessary assumptions for selection on observables:

1.  Conditional Ignorability
2.  Common Support
3.  Stable Unit Treatment Value Assumption (SUTVA)

We will need the **Matching** package.

```{r, eval = FALSE}
library(Matching)
```

Now, we can implement the matching as follows.

```{r, eval = FALSE}
att <- Match(Y = my_data$Y,
             Tr = my_data$D,
             X = my_data[,c("X1","X2", "X3")],
             M = 1,
             BiasAdjust = TRUE,
             Weight = 2)
summary(att)
```

Our output estimate will be the ATT.
